# 水果消消乐 - 动画系统重构说明

## 概述

本次重构主要解决了游戏动画系统中的多轮消除链动画同步问题，确保消除、下落、新生成水果的动画能够正确按轮次顺序播放，同时修复了分数悬浮字显示和交换动画的相关问题。

## 核心问题分析

### 问题根源

游戏引擎（GameEngine）在处理一次玩家操作时，会**一次性计算完所有轮次**的消除和下落，然后返回最终状态。但动画系统需要**逐轮播放**每个阶段的动画。

**关键矛盾**：
- `gameEngine_->getMap()` 返回的是**最终状态**（所有轮次处理完毕后）
- 动画系统需要的是**每轮的中间状态**

### 之前的错误做法

```cpp
// 错误：直接用最终状态覆盖快照
snapshotManager_->saveSnapshot(gameEngine_->getMap());
```

这导致了：
1. 第一轮下落后画面直接闪现为最终结果
2. 后续动画使用错误的地图数据
3. 水果类型在动画中显示错误

## 解决方案

### 1. 扩展 FallMove 结构体

**文件**: `src/core/GameEngine.h`

```cpp
struct FallMove {
    int fromRow = -1;
    int fromCol = -1;
    int toRow   = -1;
    int toCol   = -1;
    FruitType type = FruitType::EMPTY;      // 新增：水果类型
    SpecialType special = SpecialType::NONE; // 新增：特殊类型
};
```

**原因**：动画数据需要自包含，不能依赖外部状态。在记录下落移动时，同时记录水果类型，这样动画渲染器可以直接使用，无需查询快照或引擎状态。

### 2. 记录下落时填充类型信息

**文件**: `src/core/AnimationRecorder.cpp`

```cpp
for (const auto& move : allSteps[0]) {
    FallMove fm;
    fm.fromRow = move.first.first;
    fm.fromCol = move.first.second;
    fm.toRow = move.second.first;
    fm.toCol = move.second.second;
    // 关键：记录水果类型（此时map已经更新，从目标位置读取）
    fm.type = map[fm.toRow][fm.toCol].type;
    fm.special = map[fm.toRow][fm.toCol].special;
    outFallStep.moves.push_back(fm);
}
```

### 3. 快照管理器重构

**文件**: `ui/views/animation/SnapshotManager.cpp`

#### applyFall 方法

```cpp
void SnapshotManager::applyFall(const GameAnimationSequence& animSeq, int roundIndex)
{
    // 1. 清空所有源位置
    for (const auto& move : round.fall.moves) {
        snapshot_[fromR][fromC].type = FruitType::EMPTY;
    }
    
    // 2. 应用移动到目标位置（使用FallMove中的类型）
    for (const auto& move : round.fall.moves) {
        snapshot_[toR][toC].type = move.type;
        snapshot_[toR][toC].special = move.special;
    }
    
    // 3. 新生成的水果使用动画数据中的类型
    for (const auto& nf : round.fall.newFruits) {
        snapshot_[r][c].type = nf.type;
        snapshot_[r][c].special = nf.special;
    }
}
```

**关键改变**：不再从 `engineMap` 读取数据，而是完全使用动画序列中记录的类型信息。

### 4. 下落动画渲染器更新

**文件**: `ui/views/animation/FallAnimationRenderer.cpp`

```cpp
// 从FallMove直接获取水果类型（不再依赖snapshot）
Fruit fruit;
fruit.type = move.type;
fruit.special = move.special;
```

### 5. 交换动画隐藏机制

**文件**: `ui/views/GameView.cpp`

```cpp
void GameView::beginSwapAnimation(bool success)
{
    // 交换动画需要隐藏原位置的水果，避免重影
    snapshotManager_->updateHiddenCells(animSeq, 0, AnimPhase::SWAPPING);
    animController_->beginSwap(success);
}
```

交换动画完成后清除隐藏：
```cpp
case AnimPhase::SWAPPING:
    snapshotManager_->clearHiddenCells();  // 清除隐藏
    // ...
```

## 动画流程时序图

```
玩家交换操作
    │
    ▼
保存快照 (snapshot = 交换前状态)
    │
    ▼
引擎处理 (计算所有轮次，返回最终状态)
    │
    ▼
┌─────────────────────────────────────┐
│  交换动画 (SWAPPING)                 │
│  - 隐藏交换位置                       │
│  - 渲染器绘制插值位置                  │
│  - 完成后 applySwap 更新快照          │
└─────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────┐
│  第N轮循环                           │
│  ┌─────────────────────────────────┐│
│  │ 消除动画 (ELIMINATING)          ││
│  │ - 隐藏被消除的格子               ││
│  │ - 播放消除特效                   ││
│  │ - 添加分数悬浮字                 ││
│  └─────────────────────────────────┘│
│              │                       │
│              ▼                       │
│  ┌─────────────────────────────────┐│
│  │ 下落动画 (FALLING)              ││
│  │ - applyElimination (标记EMPTY)  ││
│  │ - 隐藏下落源位置                 ││
│  │ - 渲染器使用FallMove.type绘制   ││
│  │ - 完成后 applyFall 更新快照     ││
│  └─────────────────────────────────┘│
│              │                       │
│              ▼                       │
│        150ms 停留                    │
│              │                       │
│              ▼                       │
│      下一轮 或 结束                   │
└─────────────────────────────────────┘
    │
    ▼
清空快照，使用 engineMap 渲染最终状态
```

## 分数悬浮字系统

### 堆叠显示机制

**文件**: `ui/views/ScoreFloatOverlay.h/cpp`

```cpp
struct FloatingScoreItem {
    int score = 0;
    int combo = 0;
    float progress = 0.0f;
    float centerX = 0.0f;
    float centerY = 0.0f;
    int stackIndex = 0;     // 堆叠索引（用于垂直偏移）
    bool active = false;
};
```

**渲染偏移计算**：
```cpp
// 上浮偏移 + 堆叠偏移（让多个分数形成一长串）
float offsetY = -FLOAT_DISTANCE * fs.progress - STACK_SPACING * fs.stackIndex;
```

### 常量配置

| 常量 | 值 | 说明 |
|------|-----|------|
| MAX_FLOATING_SCORES | 10 | 最大同时显示数量 |
| ANIMATION_DURATION | 1.5s | 动画持续时间 |
| FLOAT_DISTANCE | 80px | 上浮距离 |
| STACK_SPACING | 30px | 堆叠间隔 |

### 视觉效果

- **颜色分级**：根据分数和连击数显示不同颜色（白→黄→金→橙→红→紫）
- **字体大小**：高分和高连击时字体更大
- **描边效果**：分数≥100或连击≥2时显示描边
- **缩放动画**：出现时有放大效果
- **淡出效果**：后半段动画透明度渐变

## 关键文件清单

| 文件 | 修改内容 |
|------|----------|
| `src/core/GameEngine.h` | FallMove 结构体添加 type/special 字段 |
| `src/core/AnimationRecorder.cpp` | 记录下落时填充类型信息 |
| `ui/views/animation/SnapshotManager.h/cpp` | applyFall 使用动画数据而非 engineMap |
| `ui/views/animation/FallAnimationRenderer.cpp` | 从 FallMove 获取类型 |
| `ui/views/GameView.cpp` | 交换动画隐藏机制、阶段完成处理 |
| `ui/views/ScoreFloatOverlay.h/cpp` | 堆叠显示、清除残留修复 |

## 测试要点

1. **多轮消除链**：触发3+轮连锁反应，观察每轮是否正确显示中间状态
2. **交换失败**：交换无法形成匹配时，观察是否有重影
3. **分数悬浮字**：连击时观察是否形成堆叠的一长串效果
4. **动画结束**：所有动画完成后，画面是否与引擎状态一致

## 总结

本次重构的核心思想是**让动画数据自包含**：

- `FallMove` 包含水果类型，无需查询外部状态
- `NewFruit` 包含水果类型，无需查询 engineMap
- 快照管理器按轮次增量更新，而非直接覆盖为最终状态

这样确保了动画系统与游戏引擎的解耦，每轮动画都能正确显示该轮次的中间状态。
